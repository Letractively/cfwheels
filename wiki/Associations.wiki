#summary Through some simple configuration, Wheels allows you to unlock some powerful functionality to use your database tables' relationships in your controller code.
#labels chapter,0.8.3

_*Note:* This wiki contains "bleeding edge" documentation, which may reflect a future version of Wheels. Entries in the wiki may also be incomplete and unedited. For the "official" documentation, please visit [http://www.cfwheels.com/docs Official ColdFusion on Wheels Documentation]._

_Associations_ in Wheels allow you to define the relationships between your database tables. After configuring these relationships, doing pesky table joins becomes a trivial task. And like all other ORM functions in Wheels, this is done without writing a single line of SQL.

==3 Types of Associations==

In order to set up associations, you only need to remember 3 simple functions. Considering that the human brain only reliably remembers up to 7 items, we've left you with a lot of extra space. You're welcome. :)

The association functions should always be called in the `init()` method of a model that relate to another model within your application.

===`belongsTo` Association===

If your database table contains a field that is a foreign key to another table, then this is where to use the `belongsTo()` function.

If we had a `comments` table that contains a foreign key to the `posts` table called `postId`, then we should have this `init()` method within our `Comment` model:

{{{
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset belongsTo("Post")>
    </cffunction>

</cfcomponent>
}}}

===`hasOne` and `hasMany` Associations===

On the other side of the relationship are the "has" functions. As you may have astutely guessed, these functions should be used according to the nature of the model relationship.

At this time, you need to be a little eccentric and talk to yourself. Your association should make sense in plain English language.

===An example of `hasMany()`===

So let's consider the `Post`/`Comment` relationship mentioned above for `belongsTo()`. If we were to talk to ourselves, we would say, "A post _has many_ comments." And that's how you should construct your `Post` model:

{{{
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset hasMany("Comments")>
    </cffunction>

</cfcomponent>
}}}

You may be a little concerned because our model is called `Comment` and not `Comments`. No need to worry: Wheels understands the need for the plural in conjunction with the `hasMany()` function.

And don't worry about those pesky words in the English language that aren't pluralized by just adding an "s" to the end. Wheels is smart enough to know that words like "deer" and "children" are the plurals of "deer" and "child," respectively.

===An example of `hasOne()`===

If we continue our pattern of talking to ourselves, then we could easily figure out to use `hasOne()` to set up a similar relationship.

Let's use the relationship between post and author as an example. So we'd say, "A post _has one_ author." That is, if that really is your business rule. Seems reasonable.

If our `Author` model looked like this:

{{{
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset belongsTo("Post")>
    </cffunction>

</cfcomponent>
}}}

Then our `Post` model would look like this:

{{{
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset hasOne("Author")>
    </cffunction>

</cfcomponent>
}}}

As you can see, you do not pluralize "author" in this case because there is only one author.

==Database Table Setup==

Like everything else in Wheels, we strongly recommend a default naming convention for foreign key columns in your database tables.

In this case, the convention is to use the singular name of the related table with `Id` appended to the end. So to link up our table to the `employees` table, the foreign key column should be named `employeeId`.

===Breaking the convention===

Wheels offers a way to configure your models to break this naming convention, however. This is done by using the `foreignKey` argument in your model's `belongsTo()` calls.

Let's pretend that you have a relationship between `Author` and `Post`, but you didn't use the naming convention and instead called the column `post_id`. (You just can't seem to let go of the underscores, can you?)

Your `Post`'s `init()` function would then need to look like this:

{{{
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset belongsTo(name="Author", foreignKey="post_id")>
    </cffunction>

</cfcomponent>
}}}

==Leveraging Model Associations in Your Application==

Now that we have our associations set up, let's use them to get some data into our applications.

There are a couple ways to join data via associations, which we'll go over now.

===Using the `include` Argument in `findAll()`===

To join data from related tables in our `findAll()` calls, we simply need to use the `include` argument. Let's say that we wanted to include data about the `Author` in our `findAll()` call for `Post`s.

Here's what that call would look like:

{{{
<cfset post = model("Post").findAll(include="Author")>
}}}

It's that simple. Wheels will then join the `authors` table automatically so that you can use that data along with the data from `posts`.

Note that if the relationship between `Post` and `Author` were a `hasMany` instead of `hasOne`, then you would need to call the pluralized version of the model, `findAll(include="Authors")`.

To include several tables, simply delimit the names of the models with a comma. All models should contain related associations, or else you'll get a mountain of repeated data back.

====Handling Column Naming Collisions====

There is a minor caveat to this approach. If you have a column in both associated tables with the same name, Wheels will pick just one to represent that column.

In order to include both columns, you can override this behavior with the `select` argument in the finder functions.

For example, if we had a column named `id` in both your `posts` and `authors` tables, then you could use the `select` argument like so:

{{{
<cfset post = model("Post").findAll(select="posts.id, posts.title, authors.id, authors.name", include="Author")>
}}}

You would need to hard-code all column names that you need in that case, which does remove some of the simplicity. There are always trade-offs!

===Using Dynamic Finders===

A cool feature of Wheels is the ability to use dynamic finders to get data related to your model through associations.

Let's say that we used this `findByKey()` call to get an author from the database:

{{{
<cfset author = model("Author").findByKey(params.key)>
}}}

We wouldn't necessarily need to use the `include` argument to get posts written by that author. Instead, we can use a dynamic method to get the posts, like so:

{{{
<cfset posts = author.posts()>
}}}

Wheels will use this call to figure out what SQL to call to get your data. No need for you to worry about it!

In this case, we need to be wary of the nature of the relationship in order to know whether or not to use a singular or plural. We have complete confidence in your ability to figure it out. :)

===Performance of Dynamic Finders===

You may be concerned that using a dynamic finder adds yet another database call to your application.

If it makes you feel any better, all calls in your Wheels request that generate the same SQL queries will be cached for that request. No need to worry about the performance implications of making multiple calls to the same `author.posts()` call in the scenario above, for example.

==Many-to-Many Relationships==

We can use the same 3 association functions to set up many-to-many table relationships in our models. It follows the same logic as the descriptions above, so let's jump right into an example.

Let's say that we wanted to set up a relationship `customers` and `publications`. A customer can be subscribed to many publications, and publications can be subscribed to by many customers. In our database, this relationship is linked together by a third table called `subscriptions`.

===Setting up the Models===

Here are the representative models:

{{{
<!--- Customer.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset hasMany("Subscriptions")>
    </cffunction>

</cfcomponent>
}}}

{{{
<!--- Publication.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset hasMany("Subscriptions")>
    </cffunction>

</cfcomponent>
}}}

{{{
<!--- Subscription.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset belongsTo("Customer")>
        <cfset belongsTo("Publication")>
    </cffunction>

</cfcomponent>
}}}

This assumes that there are foreign key columns in `subscriptions` called `customerId` and `publicationId`.

===Using Finders with the Many-to-Many Relationship===

At this point, it's still fairly easy to get data from the many-to-many association that we have set up above.

We can `include` the related tables to get the same effect:

{{{
<cfset publicationAndCustomers = model("Publication").findByKey(params.key, include="Subscriptions,Customers")>
}}}

Depending on the size of your tables, you may want to use the dynamic finder so the database doesn't have to send back repeats of the same `Publication` data for every single row containing a unique `Customer`. Test both scenarios to see which yields the better average performance.