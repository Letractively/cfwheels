#summary Through some simple configuration, Wheels allows you to unlock some powerful functionality to use your database tables' relationships in your code.
#labels chapter,0.9.1

_Associations_ in Wheels allow you to define the relationships between your database tables. After configuring these relationships, doing pesky table joins becomes a trivial task. And like all other ORM functions in Wheels, this is done without writing a single line of SQL.

==3 Types of Associations==

In order to set up associations, you only need to remember 3 simple methods. Considering that the human brain only reliably remembers up to 7 items, we've left you with a lot of extra space. You're welcome :)

The association methods should always be called in the `init()` method of a model that relates to another model within your application.

===The `belongsTo` Association===

If your database table contains a field that is a foreign key to another table, then this is where to use the [belongsTo belongsTo()] function.

If we had a `comments` table that contains a foreign key to the `posts` table called `postid`, then we would have this `init()` method within our `comment` model:

{{{
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset belongsTo("post")>
    </cffunction>

</cfcomponent>
}}}

===The `hasOne` and `hasMany` Associations===

On the other side of the relationship are the "has" functions. As you may have astutely guessed, these functions should be used according to the nature of the model relationship.

At this time, you need to be a little eccentric and talk to yourself. Your association should make sense in plain English language.

===An example of `hasMany`===

So let's consider the `post` / `comment` relationship mentioned above for [belongsTo belongsTo()]. If we were to talk to ourselves, we would say, "A post _has many_ comments." And that's how you should construct your `post` model:

{{{
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset hasMany("comments")>
    </cffunction>

</cfcomponent>
}}}

You may be a little concerned because our model is called `comment` and not `comments`. No need to worry: Wheels understands the need for the plural in conjunction with the [hasMany hasMany()] method.

And don't worry about those pesky words in the English language that aren't pluralized by just adding an "s" to the end. Wheels is smart enough to know that words like "deer" and "children" are the plurals of "deer" and "child," respectively.

===An Example of `hasOne`===

The [hasOne hasOne()] association is not used as often as the [hasMany hasMany()] association but it has its use cases. The most common use case is when you have a large table that you have broken down into two or more smaller tables (a.k.a. denormalization) for performance reasons or otherwise. Let's take the example of the association between `user` and `profile`. A lot of websites allow you to enter required info such as name, email but also add optional information such as age, salary etc. These can of course be stored in the same table but given the fact that so much information is optional it would make more sense to have the required info in a `users` table and the optional info in a `profiles` table. This gives us a [hasOne hasOne()] relationship between these two models; "A user _has one_ profile".

In this case our `profile` model would look like this:

{{{
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset belongsTo("user")>
    </cffunction>

</cfcomponent>
}}}

And our `user` model would look like this:

{{{
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset hasOne("profile")>
    </cffunction>

</cfcomponent>
}}}

As you can see, you do not pluralize "profile" in this case because there is only one profile.

By the way, as you can see above the association goes both ways, i.e. a `user` [hasOne hasOne()] `profile` and a `profile` [belongsTo belongsTo()] a `user`. Generally speaking all associations should be setup this way. This will give you the fullest API to work with in terms of the methods and arguments that Wheels makes available to you. However, it's not a definite requirement. Wheels associations are completely independent of one another so it's perfectly OK to setup a [hasMany hasMany()] association without specifying the related [belongsTo belongsTo()] association.

==Database Table Setup==

Like everything else in Wheels, we strongly recommend a default naming convention for foreign key columns in your database tables.

In this case, the convention is to use the singular name of the related table with `id` appended to the end. So to link up our table to the `employees` table, the foreign key column should be named `employeeid`.

===Breaking the convention===

Wheels offers a way to configure your models to break this naming convention, however. This is done by using the `foreignKey` argument in your model's [belongsTo belongsTo()] calls.

Let's pretend that you have a relationship between `author` and `post`, but you didn't use the naming convention and instead called the column `post_id`. (You just can't seem to let go of the underscores, can you?)

Your `post`'s `init()` function would then need to look like this:

{{{
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset belongsTo(name="author", foreignKey="post_id")>
    </cffunction>

</cfcomponent>
}}}

==Leveraging Model Associations in Your Application==

Now that we have our associations set up, let's use them to get some data into our applications.

There are a couple ways to join data via associations, which we'll go over now.

===Using the `include` Argument in `findAll`===

To join data from related tables in our [findAll findAll()] calls, we simply need to use the `include` argument. Let's say that we wanted to include data about the `author` in our [findAll findAll()] call for `post`s.

Here's what that call would look like:

{{{
<cfset posts = model("post").findAll(include="author")>
}}}

It's that simple. Wheels will then join the `authors` table automatically so that you can use that data along with the data from `posts`.

Note that if you switch the above statement around like this:

{{{
<cfset authors = model("author").findAll(include="posts")>
}}}

You would then have to specify "post" in its plural form; "posts". If you're thinking about when to use the singular form and when to use the plural form just use the one that seems most natural. If you look at the two examples above you'll see that in example #1 you're asking for all posts including each post's *author* (hence the singular "author") and in example #2 you're asking for all authors and all of the *posts* (hence the plural "posts") written by each author.

You're not limited to specifying just one association in the `include` argument. You can for example return data for authors, posts and bios in one call like this:

{{{
<cfset authorsPostsAndComments = model("author").findAll(include="posts,bio")>
}}}

To include several tables, simply delimit the names of the models with a comma. All models should contain related associations, or else you'll get a mountain of repeated data back.

When you want to include tables more than one step away you need to start using parenthesis. Look at the following example:

{{{
<cfset commentsPostsAndAuthors = model("comment").findAll(include="post(author)")>
}}}

The use of parentheses above tells Wheels to look for an association named `author` on the `post` model instead of on the `comment` model, which is the default behavior.

====Handling Column Naming Collisions====

There is a minor caveat to this approach. If you have a column in both associated tables with the same name, Wheels will pick just one to represent that column.

In order to include both columns, you can override this behavior with the `select` argument in the finder functions.

For example, if we had a column named `name` in both your `posts` and `authors` tables, then you could use the `select` argument like so:

{{{
<cfset post = model("post").findAll(select="posts.name, authors.id, authors.post_id, authors.name AS author_name", include="author")>
}}}

You would need to hard-code all column names that you need in that case, which does remove some of the simplicity. There are always trade-offs!

===Using Dynamic Shortcut Methods===

A cool feature of Wheels is the ability to use _dynamic_ _shortcut_ methods to work with the models you have setup associations for. By _dynamic_ we mean that the name of the method depends on what name you have given the association when you set it up. By _shortcut_ we mean that the method usually delegates the actual processing to another Wheels method but gives you, the developer, an easier way to achieve the task (and makes your code more readable in the process). 

As usual this will make more sense when put into the context of an example so let's do that right now...

Let's say that you tell Wheels, through a [hasMany hasMany()] call, that a `post` has many `comments`. What happens then is that Wheels will enrich the `post` model by adding a bunch of useful methods related to this association. If you wanted to get all comments that have been submitted for a post you can now do this by calling `post.comments()` for example. In the background Wheels will delegate this to a [findAll findAll()] call with the `where` argument set to `postId=#post.id#`.

Here are all the methods that are added for the three possible association types.

*Methods Added by `hasMany`*

Given that you have told Wheels that a `post` has many `comments` through a [hasMany hasMany()] call, here are the methods that will be made available to you on the `post` model. Replace `XXX` below with the name of the association, i.e. `comments` in the case of the example we're using here.

[XXX XXX()], `post.comments()`. Returns all comments where the foreign key matches the posts primary key value. Similar to calling `model("comment").findAll(where="postId=#post.id#")`.

[addXXX addXXX()], `post.addComment(comment)`. Adds a comment to the post association by setting its foreign key to the posts primary key value. Similar to calling `comment.updateByKey(key=comment.id, postId=post.id)`.

[removeXXX removeXXX()], `post.removeComment(comment)`. Removes a comment from the post association by setting its foreign key to `NULL`. Similar to calling `comment.updateByKey(key=comment.id, postId="")`.

[deleteXXX deleteXXX()], `post.deleteComment(comment)`. Deletes the associated comment from the database table. Similar to calling `model("comment").deleteByKey(key=comment.id)`.

[removeAllXXX removeAllXXX()], `post.removeAllComments()`. Removes all comments from the post association by setting their foreign keys to `NULL`. Similar to calling `model("comment").updateAll(postId="", where="postId=#post.id#")`.

[deleteAllXXX deleteAllXXX()], `post.deleteAllComments()`. Deletes the associated comments from the database table. Similar to calling `model("comment").deleteAll(where="postId=#post.id#")`.

[XXXCount XXXCount()], `post.commentCount()`. Returns the number of associated comments. Similar to calling `model("comment").count(where="postId=#post.id#")`.

[newXXX newXXX()], `post.newComment()`. Creates a new comment object. Similar to calling `model("comment").new(postId=post.id)`.

[createXXX createXXX()], `post.createComment()`. Creates a new comment object and saves it to the database. Similar to calling `model("comment").create(postId=post.id)`.

[hasXXX hasXXX()], `post.hasComments()`. Returns `true` if the post has any comments associated with it. Similar to calling `model("comment").exists(where="postId=#post.id#")`.

[findOneXXX findOneXXX()], `post.findOneComment()`. Returns one of the associated comments. Similar to calling `model("comment").findOne(where="postId=#post.id#")`.

*Methods Added by `hasOne`*

The [hasOne hasOne()] association adds a few methods as well, most of them are very similar to the ones added by [hasMany hasMany()]. Given that you have told Wheels that an `author` has one `profile` through a [hasOne hasOne()] call, here are the methods that will be made available to you on the `author` model.

[XXX XXX()], `author.profile()`. Returns the profile where the foreign key matches the author's primary key value. Similar to calling `model("profile").findOne(where="authorId=#author.id#")`.

[setXXX setXXX()], `author.setProfile(profile)`. Sets the profile to be associated with the author by setting its foreign key to the author's primary key value. You can pass in either a `profile` object or the primary key value of a `profile` object to this method. Similar to calling `model("profile").updateByKey(key=profile.id, authorId=author.id)`.

[removeXXX removeXXX()], `author.removeProfile()`. Removes the profile from the author association by setting its foreign key to `NULL`. Similar to calling `model("profile").updateOne(where="authorId=#author.id#", authorId="")`.

[deleteXXX deleteXXX()], `author.deleteProfile()`. Deletes the associated profile from the database table. Similar to calling `model("profile").deleteOne(where="authorId=#author.id#")`.

[newXXX newXXX()], `author.newProfile()`. Creates a new profile object. Similar to calling `model("profile").new(authorId=author.id)`.

[createXXX createXXX()], `author.createProfile()`. Creates a new profile object and saves it to the database. Similar to calling `model("profile").create(authorId=author.id)`.

[hasXXX hasXXX()], `author.hasProfile()`. Returns `true` if the author has an associated profile. Similar to calling `model("profile").exists(where="authorId=#author.id#")`.

*Methods Added by `belongsTo`*

The [belongsTo belongsTo()] association adds a couple of methods to your model as well. Given that you have told Wheels that a `comment` belongs to a `post` through a [belongsTo belongsTo()] call, here are the methods that will be made available to you on the `comment` model.

[XXX XXX()], `comment.post()`. Returns the post where the primary key matches the comment's foreign key value. Similar to calling `model("post").findByKey(comment.postId)`.

[hasXXX hasXXX()], `comment.hasPost()`. Returns `true` if the comment has a post associated with it. Similar to calling `model("post").exists(comment.postId)`.

One general rule for all of the methods above is that you can always supply any argument that is accepted by the method that the processing is delegated to and it will be passed through. This means that you can for example call `post.comments(order="createdAt DESC")` and the `order` argument will be passed along to [findAll findAll()].

Another rule is that whenever a method accepts an object as its first argument you also have the option of supplying the primary key value instead. This means that `author.setProfile(profile)` will perform the same task as `author.setProfile(1)` for example (we're assuming that the `profile` object in this example has a primary key value of `1` of course).

===Performance of Dynamic Association Finders===

You may be concerned that using a dynamic finder adds yet another database call to your application.

If it makes you feel any better, all calls in your Wheels request that generate the same SQL queries will be cached for that request. No need to worry about the performance implications of making multiple calls to the same `author.posts()` call in the scenario above, for example.

==Many-to-Many Relationships==

We can use the same 3 association functions to set up many-to-many table relationships in our models. It follows the same logic as the descriptions above, so let's jump right into an example.

Let's say that we wanted to set up a relationship `customers` and `publications`. A customer can be subscribed to many publications, and publications can be subscribed to by many customers. In our database, this relationship is linked together by a third table called `subscriptions`.

===Setting up the Models===

Here are the representative models:

{{{
<!--- Customer.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset hasMany("subscriptions")>
    </cffunction>

</cfcomponent>
}}}

{{{
<!--- Publication.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset hasMany("subscriptions")>
    </cffunction>

</cfcomponent>
}}}

{{{
<!--- Subscription.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset belongsTo("customer")>
        <cfset belongsTo("publication")>
    </cffunction>

</cfcomponent>
}}}

This assumes that there are foreign key columns in `subscriptions` called `customerid` and `publicationid`.

===Using Finders with a Many-to-Many Relationship===

At this point, it's still fairly easy to get data from the many-to-many association that we have set up above.

We can `include` the related tables from the `subscription` bridge entity to get the same effect:

{{{
<cfset data = model("subscription").findAll(include="customer,publication")>
}}}