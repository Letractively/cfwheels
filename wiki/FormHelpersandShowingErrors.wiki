#summary Wheels ties your application's forms together with your model layer elegantly. With Wheels form conventions, you'll find yourself spending less time writing repetitive markup to display forms and error messages.
#labels 0.9.4,draft,chapter

The majority of applications are not all about back-end. There is a great deal of work to perform on the front-end as well. It can be argued that most of your users will think of the interface _as_ the application.

Wheels is here to take you to greener pastures with its [ViewHelperFunctions Helper Functions]. Let's get visual with some code examples.

==Simple Example: The Old Way==

Here is a simple form for editing a user profile. Normally, you would code your web form similarly to this:

{{{
<cfoutput>

<form action="/profile/save" method="post">

    <div>
        <label for="firstName">First Name</label>
        <input id="firstName" name="firstName" value="#profile.firstName#" />
    </div>

    <div>
        <label for="lastName">Last Name</label>
        <input id="lastName" name="lastName" value="#profile.lastName#" />
    </div>

    <div>
        <label for="department">Department</label>
        <select id="department" name="departmentId">
            <cfloop query="departments">
                <option
                    value="#departments.id#"
                    <cfif profile.departmentId eq departments.id>
                        selected="selected"
                    </cfif>
                >#departments.name#</option>
            </cfloop>
        </select>
    </div>
    
    <div>
        <input type="hidden" name="id" value="#department.id#" />
        <input type="submit" value="Save Changes" />
    </div>
</form>

</cfoutput>
}}}

Then you would write a script for the form that validates the data submitted, handles interactions with different data sources, and displays the form with errors that may happen as a result of user input.

We know that you are quite familiar with the drudgery of typing this sort of code over and over again. Let's not even mention the pain associated with debugging it or adding new fields and business logic!

==Making Life Easier: Wheels Form Helpers==

The good news is that Wheels simplifies this quite a bit for you. At first, it looks a little different using these conventions. But you'll quickly see how it all ties together and saves you some serious time.

===Rewriting the Form with Wheels Conventions===

Let's rewrite and then explain.

{{{
<cfoutput>

#startFormTag(action="save")#

    #textField(label="First Name", objectName="profile", property="firstName", prependToLabel="<div>", append="</div>", wrapLabel=false)#
    #textField(label="Last Name", objectName="profile", property="lastName", prependToLabel="<div>", append="</div>", wrapLabel=false)#
    #select(label="Department", objectName="profile", property="departmentId", options=departments, prependToLabel="<div>", append="</div>", wrapLabel=false)#
    <div>
        #hiddenField(objectName="department", property="id")#
        #submitTag()#
    </div>

#endFormTag()#

</cfoutput>
}}}

I know what you are thinking. 9 lines of code can't replace all that work, right? In fact, they do. The HTML output will be exactly the same as the previous example. By using Wheels conventions, you are saving yourself a lot of key strokes and a great deal of time.

===Factoring out Common Settings with Global Defaults===

By setting up global defaults (as explained in the [ConfigurationandDefaults Configuration and Defaults] chapter) for the `prependToLabel`, `append`, and `wrapLabel` arguments, you can make the form code ever simpler across your whole application.

Here are the settings that you would apply in `config/settings.cfm`:

{{{
<cfset set(functionName="textField", prependToLabel="<div>", append="</div>", wrapLabel=false)>
<cfset set(functionName="select",prependToLabel="<div>", append="</div>", wrapLabel=false)>
}}}

And here's how our example code can be simplified as a result:

{{{
<cfoutput>

#startFormTag(action="save")#

    #textField(label="First Name", objectName="profile", property="firstName")#
    #textField(label="Last Name", objectName="profile", property="lastName")#
    #select(label="Department", objectName="department")#
    <div>
        #hiddenField(objectName="profile", property="departmentId", options=departments)#
        #submitTag()#
    </div>

#endFormTag()#

</cfoutput>
}}}

All that the controller needs to provide at this point is a model object instance named `profile` that contains `firstName`, `lastName`, and `departmentId` properties and a query object named `departments` that contains identifier and text values. Note that the instance variable is named `profile`, though the model itself doesn't necessarily need to be named `profile`.

If you pass the form an empty instance named `profile` (for example, created by [new new()], the form will display blank values for all the fields. If you pass it an object created by a finder like `[findOne findOne()]` or `[findByKey findByKey()]`, then the form will display the values provided through the object. This allows for us to potentially use the same view file for both create and update scenarios in our application.

==Form Feedback==

If you really want to secure a form, you need to do it server side. Sure, you can add !JavaScript here and there to validate your web form. Unfortunately, disabling !JavaScript (and thus your !JavaScript-powered form validation) is simple in web browsers, and (God forbid) malicious bots tend not to listen to !JavaScript.

Securing the integrity of your web forms in Wheels on the server side is very easy. Assuming that you have read the chapter on [ObjectValidation Object Validation], you can rest assured that your code is a lot more secure now.

===Displaying a List of Model Validation Errors===

Wheels provides you with a tool set of [ViewHelperFunctions Helper Functions] just for displaying error messages as well.

In the controller, let's say that this just happened. Your model includes validations that require the presence of both `firstName` and `lastName`. The user didn't enter either. So in the controller's `save` action, it loads the model object, sets the values that the user submitted, sees that there was a validation error after calling [save save()], and displays the form view again.

The `save` action may look something like this:

{{{
<cffunction name="save">

    <cfif isPost() and StructKeyExists(params, "profile")>
        <!--- In this example, we're loading a new object with the form data --->
        <cfset profile = model("userProfile").new(params.profile)>
        <cfset profile.save()>
        
        <!--- If there were errors with the form submission, show the form again with errors --->
        <cfif profile.hasErrors()>
            <cfset renderPage(template="profileForm")>
        <!--- If everything validated, then send user to success message --->
        <cfelse>
            <cfset flashInsert(success="The user profile for #profile.firstName# #profile.lastName# was created successfully.")>
            <cfset redirectTo(controller=params.controller)>
        </cfif>
    </cfif>

</cffunction>
}}}

Notice that the `profileForm` template is called if the `profile` object's [hasErrors hasErrors()] method returns `true`.

Let's take the previous form example and add some visual indication to the user about what he did wrong and where, by simply adding the following code on your form page.

{{{
<cfoutput>

#errorMessagesFor("profile")#

#startFormTag(action="save")#

    #textField(label="First Name", objectName="profile", property="firstName")#
    #textField(label="Last Name", objectName="profile", property="lastName")#
    #select(label="Department", objectName="department")#
    <div>
        #hiddenField(objectName="department", property="id")#
        #submitTag()#
    </div>

#endFormTag()#

</cfoutput>
}}}

How about that? With just that line of code (and the required validations on your object model), Wheels will do the following: 

 * Generate an HTML unordered list with a HTML class name of `error-messages`. 
 * Display all the error messages on your `profile` object as list items in that unordered list.
 * Wrap each of the erroneous fields in your form with a surrounding `<div class="field-with-errors">` HTML tag for you to enrich with your ninja CSS skills.

There is no longer the need to manually code error logic in your form markup.

===Showing Individual Fields' Error Messages===

Let's say that would rather display the error messages just below the failed fields (or anywhere else, for that matter). Wheels has that covered too. All that it takes is a simple line of code for each form field that could end up displaying feedback to the user. 

Lets get practical and create some error messages for the `firstName` and `lastName` fields:

{{{
<cfoutput>

#startFormTag(action="save")#

    #textField(label="First Name", objectName="profile", property="firstName")#
    #errorMessageOn(objectName="profile", property="firstName")#

    #textField(label="Last Name", objectName="profile", property="lastName")#
    #errorMessageOn(objectName="profile", property="lastName")#

    #selectTag(label="Department", objectName="department")#

    <div>
        #hiddenField(objectName="profile", property="departmentId", options=departments)#
        #submitTag()#
    </div>

#endFormTag()#

</cfoutput>
}}}

Notice the call to the [errorMessageOn errorMessageOn] function below the `firstName` and `lastName` fields. That's all it takes to display the corresponding error messages of each form control on your form.

And the error message(s) won't even display if there isn't one. That way you can yet again use the same form code for error and non-error scenarios alike.

==Types of Form Helpers==

There is a Wheels form helper for basically every type of form element available in HTML. And they all have the ability to be bound to Wheels model instances to make displaying values and errors easier. Here is a brief description of each helper.

===Text and Password Fields===

Text and password fields work similarly to each other. They allow you to show labels and bind to model object instances to determine whether or not a value should be pre-populated.

{{{
#textField(label="Username", objectName="user", property="username")#
#passwordField(label="Password", objectName="user", property="password")#
}}}

May yield the equivalent to this HTML (if we assume the global defaults defined above in the section named _Factoring out Common Settings with Global Defaults_):

{{{
<div>
    <label for="user-username">Username</label>
    <input id="user-username" type="text" name="user[username]" value="cfguy" />
</div>
<div>
    <label for="user-password">Password</label>
    <input id="user-password" type="password" name="user[password]" value="" />
</div>
}}}

===Hidden Fields===

Hidden fields are powered by the [hiddenField hiddenField()] form helper, and it also works similarly to how [textField textField()] and [passwordField passwordField()] work.

{{{
#hiddenField(objectName="user", property="id")#
}}}

Could yield this type of markup:

{{{
<input type="hidden" name="user[id]" value="425" />
}}}

Obviously, the big difference is that hidden fields do not have labels.

===Select Fields===

As hinted in our first example of form helpers, the [select select()] function builds a `<select>` list with options. What's really cool about this helper is that it can populate the `<option>`s with values from a query.

Take a look at this line:

{{{
#select(label="Department", objectName="user", property="departmentId", options=departments)#
}}}

Assume that the `departments` variable passed to the `options` argument contains a query of departments that should be selectable in the drop-down.

===Radio Buttons===

Radio buttons also take `objectName` and `property` values, and they accept an argument called `tagValue` that determines whether or not the button should be checked on load.

Here is an example using a query object called `eyeColor` to power the possible values:

{{{
<fieldset>
    <legend>Eye Color</legend>
    <cfloop query="eyeColor">
        #radioButton(label=eyeColor.color, objectName="profile", property="eyeColorId", tagValue=eyeColor.id)#<br />
    </cfloop>
</fieldset>
}}}

The rendered HTML would appear similar to this:

{{{
<fieldset>
    <legend>Eye Color</legend>
    <label>Blue <input type="checkbox" id="profile-eyeColorId-2" name="profile[eyeColorId]" value="2" /></label><br />
    <label>Brown <input type="checkbox" id="profile-eyeColorId-1" name="profile[eyeColorId]" value="1" /></label><br />
    <label>Hazel <input type="checkbox" id="profile-eyeColorId-3" name="profile[eyeColorId]" value="3" /></label><br />
</fieldset>
}}}

===Check Boxes===

Check boxes work similarly to radio buttons, except it takes parameters called `checkedValue` and `uncheckedValue` to determine whether or not the check box should be checked on load.



==Passing Extra Arguments for HTML Attributes==

Much like Wheels's [linkTo linkTo()] function, any extra arguments that you pass to form helpers will be passed to the corresponding HTML tag as attributes.

For example, if we wanted to define a `class` and `enctype` on our starting form tag, we just pass those as extra arguments to [startFormTag startFormTag()]:

{{{
#startFormTag(action="save", class="login-form", enctype="multipart/form-data")#
}}}

Which would produce this HTML:

{{{
<form action="/user/save" class="login-form" enctype="multipart/form-data">
}}}