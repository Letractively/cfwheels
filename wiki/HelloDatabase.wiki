#summary A quick tutorial that demonstrates how quickly you can get database connectivity up and running with Wheels.
#labels chapter

Wheels's built in model provides your application with some simple and powerful functionality for interacting with databases. To get started, you make some simple configurations, call some functions within your controllers, and that's it. Best yet, you will rarely ever need to write SQL code to get those redundant CRUD tasks out of the way.

==Our Sample Application: User Management and Authentication==

We'll learn by building part of a sample authentication and user management application. This tutorial will teach you the basics of interacting with Wheels's ORM (which is short for object relational mapping).

==Setting up the Data Source==

By default, Wheels will connect to a data source that has the same name as the folder containing your Wheels application. So if your Wheels application is in a folder called `C:\websites\mysite\blog\`, then it will connect to a data source named `blog`.

To change this default behavior, open the file at `config/settings.cfm`. In a fresh install of Wheels, you'll see some commented-out lines of code that read as such:

{{{
<!---
	If you leave these settings commented out, Wheels will set the data source name to the same name as the folder the application resides in.
	<cfset set(dataSourceName="")>
	<cfset set(dataSourceUserName="")>
	<cfset set(dataSourcePassword="")> 
--->
}}}

Uncomment the lines that you need to tell Wheels what it needs to know about the data source and provide the appropriate values, which may include `dataSourceName`, `dataSourceUserName`, and `dataSourcePassword`.

{{{
<cfset set(dataSourceName="myblogapp")>
}}}

===Our Sample Data Structure===

Wheels supports MySQL, SQL Server, and Oracle. It doesn't matter which DBMS you use. We will all be writing the same CFML code to interact with the database.

That said, here's a quick look at a table that you'll need in your database:

===Table: `users`===
|| *Column Name* || *Data Type* || *Extra* ||
|| id || `int` || auto increment, primary key ||
|| name || `varchar(100)` || ||
|| email || `varchar(255)` || ||
|| password || `varchar(15)` || ||


Note a few things about these tables:
 # The table names are plural.
 # Each table has an auto-incrementing primary key named `id`.

These are database _conventions_ used by Wheels. This framework strongly encourages that everyone follow convention over configuration. That way everyone's doing things the same way, leading to less maintenance headaches down the road.

Fortunately, there are ways of going outside of these conventions when you really need to. But let's learn the conventional way first. Sometimes you need to learn the rules before you can know how to break them, cowboy.

==Adding Users==

First, let's create a simple form for adding a new user to the `users` table. To do this, we will use Wheels's _form helper_ functions. Wheels includes a whole range of functions that simplifies all of the tasks that you need to display forms and communicate errors to the user.

===Creating the Form===

Now create a new file in `views/users` called `add.cfm`. This will contain the view code for our simple form.

Next, add these lines of code to the new file:

{{{
<cfoutput>

<h1>Create a New User</h1>

#startFormTag(action="create")#

    <div>#textField(objectName="user", property="name", label="Name")#</div>

    <div>#textField(objectName="user", property="email", label="Email")#</div>

    <div>#passwordField(objectName="user", property="password", label="Password")#</div>

    <div>#submitTag()#</div>

#endFormTag()#

</cfoutput>
}}}

====Form Helpers====

What we've done here is use _form helpers_ to generate all of the form fields necessary for creating a new user in our database. It may feel a little strange using functions to generate form elements, but it will soon become clear why we're doing this. Trust us on this one... You'll love it!

To generate the form's `action` attribute, the `startFormTag()` function takes parameters similar to the `linkTo()` function that we introduced in the HelloWorld tutorial. We can pass in `controller`, `action`, `key`, and other route- and parameter-defined URLs just like we do with `linkTo()`.

To end the form, we use the `endFormTag()` function. Easy peasy, lemon squeezy.

The `textField()` and `passwordField()` helpers are similar. As you probably guessed, they create `<input>` elements with `type="text"` and `type="password"`, respectively. And the `submitTag()` function creates an `<input type="submit">` element.

One thing you'll notice is the `textField()` and `passwordField()` functions accept arguments called `objectName` and `property`. As it turns out, this particular view code will throw an error because these functions are expecting an object named `user`. Let's fix that.

===Supplying the Form with Data===

We need to supply our view code with an object called `user`. Because the controller is responsible for defining the values of data, we'll set it there.

As it turns out, our controller needs to provide the view with a blank `user` object (whose instance variable will also called `user` in this case). In our `add` action, we will use the `model()` function to generate a new instance of the `user` model.

To get a blank set of properties in the model, we'll also call the generated model's `new()` method.

{{{
<cfset user = model("user").new()>
}}}

*Note:* Wheels will automatically know that we're talking about the `users` database table when we instantiate a `user` model. The convention: database tables are plural and their corresponding Wheels models are singular.

Why is our model name singular instead of plural? When we're talking about a single record in the `users` database, we represent that with a model object. So the `users` table contains many `user` objects. It just works better in conversation.

===The Generated Form===

Now when we run the URL at `http://localhost/users/add`, we'll see the form with the fields that we defined.

The HTML generated by your application will look something like this:

{{{
<form action="/users/create" method="post">

    <div><label for="user-name">Name<input id="user-name" type="text" value="" name="user[name]" /></label></div>

    <div><label for="user-email">Email<input id="user-email" type="text" value="" name="user[email]" /></label></div>

    <div><label for="user-password">Password<input id="user-password" type="password" value="" name="user[password]" /></label></div>

    <div><input value="Save changes" type="submit" /></div>

</form>
}}}

So far we have a fairly well-formed, accessible form, without writing a bunch of repetitive markup.

===Handling the Form Submission===

Next, we'll code the `create` action in the controller to handle the form submission and save the new user to the database.

A basic way of doing this is using the model object's [create create()] method:

{{{
<cffunction name="create">

    <cfset model("user").create(params.user)>
    <cfset flashInsert(success="User #params.user.name# created successfully.")>
    <cfset redirectTo(action="index")>

</cffunction>
}}}

Because we used the `objectName` argument in the fields of our form, we can access the data as a struct in the `params` struct.

There are more things that we can do in the `create` action to handle validation, but let's keep it simple in this chapter.

==Listing Users==

Notice that our `create` action above redirects the user to the `index` action. We'll use this action to list all `users` in the system with "Edit" links. We'll also provide a link to the create form that we just coded.

First, let's get the data that the listing needs. Create an action named `index` in the `users` controller like so:

{{{
<cffunction name="index">

    <cfset users = model("user").findAll(order="name")>

</cffunction>
}}}

This call to the model's [findAll findAll()] method will return a query object of all `users` in the system. By using the method's `order` argument, we're also telling the database to order the records by `name`.

In the view at `views/users/index.cfm`, it's as simple as looping through the query and outputting the data.

{{{
<cfoutput>

<h1>Users</h1>

<cfif flashKeyExists("success")>
    <p class="success">#flash("success")#</p>
</cfif>

<p>#linkTo(text="+ Add New User", action="user")#</p>

<table>
    <thead>
        <tr>
            <th>Name</th>
            <th>Email</th>
            <th></th>
        </tr>
    </thead>
    <tbody>
        <cfloop query="users">
            <tr>
                <td>#users.name#</td>
                <td>#users.email#</td>
                <td>#linkTo(text="Edit", action="edit", key=users.id, title="Edit #users.name#")</td>
            </tr>
        </cfloop>
    </tbody>
</table>

</cfoutput>
}}}