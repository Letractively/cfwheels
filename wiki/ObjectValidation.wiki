#summary Wheels utilizes validation setup within the model to enforce appropriate data constraints and persistence. Validation may be performed for saves, creates, and updates.
#labels chapter,0.9.4,draft

==Basic Setup==

In order to establish the full cycle of validation, 3 elements need to be in place:

 # A *model* file containing business logic for the database table. Example: `models/User.cfc`
 # A *controller* file for creating, saving or updating a model instance. Example: `controllers/Users.cfc`
 # A *view* file for displaying the original data inputs and an error list. Example: `views/users/index.cfm`

*Note:* Saving, creating, and updating model objects can also be done from the model file itself (or even in the view file if you want to veer completely off into the wild). But to keep things simple, all examples in this chapter will revolve around code in the controller files.

===The Model===

Validations are always defined in the `init()` method of your model. This keeps everything nice and tidy because another developer can check `init()` to get a quick idea on how your model behaves.

Let's dive right into a somewhat comprehensive example:

{{{
<cfcomponent extends="Model" output="false">
  
    <cffunction name="init">
        <cfset validatesPresenceOf(properties="firstName,lastName,email,age,password")>
        <cfset validatesLengthOf(properties="firstName,lastName", maximum=50)>
        <cfset validatesUniquenessOf(property="email")>
        <cfset validatesNumericalityOf(property="age", onlyInteger=true)>
        <cfset validatesConfirmationOf(property="password")>
    </cffunction>

</cfcomponent>
}}}

This is fairly readable on its own, but this example defines the following rules that will be run before a create, update, or save is called:

 * The `firstName`, `lastName`, `email`, `age`, and `password` fields must be provided, and they can't be blank.
 * At maximum, `firstName` and `lastName` can each be up to 50 characters long.
 * The value provided for `email` cannot already be used in the database.
 * The value for `age` can only be an integer.
 * `password` must be provided twice, the second time via a field called `passwordConfirmation`.

If any of these validations fail, Wheels will not commit the create or update to the database. As you'll see later in this chapter, the controller should check for this and react accordingly by showing error messages generated by the model.

====Listing of Validation Functions====

Wheels provides quite a few useful model validation functions. These functions remove much of the tedious drudgery that you're probably used to when writing data validation.

 * [validatesConfirmationOf validatesConfirmationOf()]
 * [validatesExclusionOf validatesExclusionOf()]
 * [validatesFormatOf validatesFormatOf()]
 * [validatesInclusionOf validatesInclusionOf()]
 * [validatesLengthOf validatesLengthOf()]
 * [validatesNumericalityOf validatesNumericalityOf()]
 * [validatesPresenceOf validatesPresenceOf()]
 * [validatesUniquenessOf validatesUniquenessOf()]
 * [validate validate()]
 * [validateOnCreate validateOnCreate()]
 * [validateOnUpdate validateOnUpdate()]

===The Controller===

The controller continues with the simplicity of validation setup, and at the most basic level requires only 5 lines of code to persist the form data or return to the original form page to display the list of errors.

{{{
<cfcomponent extends="Controller" output="false">

    <cffunction name="save">
        <!--- User model from form fields via params --->
        <cfset newUser = model("user").new(params.newUser)>

        <!--- Persist new user --->
        <cfif newUser.save()>
            <cfset redirectTo(action="success")>
        <!--- Handle errors --->
        <cfelse>
            <cfset renderPage(action="index")>
        </cfif>
    </cffunction>

</cfcomponent>
}}}

The first line of the action creates a `newUser` based on the `user` model and the form inputs (via the `params` struct).

Now, to persist the object to the database, the model's [save save()] call can be placed within a `<cfif>` test. If the save succeeds, the [save save()] method will return `true`, and the contents of the `<cfif>` will be executed. But if any of the validations set up in the model fail, the [save save()] method returns `false`, and the `<cfelse>` will execute.

The important step here is to recognize that the `<cfelse>` renders the original form input page using the [renderPage renderPage()] function. If a [redirectTo redirectTo()] were used instead, the validation information would be lost.

===The View===

Wheels factors out much of the error display code that you'll ever need. As you can see by this quick example, it appears to mainly be a normal form. But when there are errors in the provided model, Wheels will apply styles to the erroneous fields.

{{{
<cfoutput>

#errorMessagesFor("newUser")#

#startFormTag(action="apply")#
    #textField(label="First Name", objectName="newUser", property="nameFirst")#
    #textField(label="Last Name", objectName="newUser", property="nameLast")#
    #textField(label="Email", objectName="newUser", property="email")#
    #textField(label="Age", objectName="newUser", property="age")#
    #passwordField(label="Password", objectName="newUser", property="password")#
    #passwordField(label="Re-type Password to Confirm", objectName="newUser", property="passwordConfirmation")#
    #submitTag()#
#endFormTag()#

</cfoutput>
}}}

The biggest thing to note in this example is that a field called `passwordConfirmation` was provided so that the [validatesConfirmationOf validatesConfirmationOf()] validation in the model can be properly tested.

For more information on how this code behaves when there is an error, refer to the FormHelpersandShowingErrors chapter.

==Error Messages==

For your reference, here are the default error message formats for the different validation functions:

|| *Function* || *Format* ||
|| `validatesConfirmationOf` || [[property]] should match confirmation ||
|| `validatesExclusionOf` || [[property]] is reserved ||
|| `validatesFormatOf` || [[property]] is invalid ||
|| `validatesInclusionOf` || [[property]] is not included in the list ||
|| `validatesLengthOf` || [[property]] is the wrong length ||
|| `validatesNumericalityOf` || [[property]] is not a number ||
|| `validatesPresenceOf` || [[property]] can't be empty ||
|| `validatesUniquenessOf` || [[property]] has already been taken ||

===Custom Error Messages===

Wheels models provide a set of sensible defaults for validation errors. But sometimes you may want to show something different than the default.

There are 2 ways to accomplish this: through global defaults in your config files or on a per-field basis.

===Setting Global Defaults for Error Messages===

Using basic global defaults for the validation functions, you can set error messages in your config file at `config/settings.cfm`.

<cfset set(functionName="validatesPresenceOf", message="Please provide a value for [property]")>

As you can see, you can inject the property's name by adding `[[property]]` to the message string. Wheels will automatically separate words based on your camelCasing of the variable names.

===Setting an Error Message for a Specific Model Property===

Another way of adding a custom error message is by going into an individual property in the model and adding an argument named `message`.

Here's a change that we may apply in the `init()` method of our model:

{{{
<cfset validatesNumericalityOf(property="email", message="Email address is already in use in another account")>
}}}