#summary Wheels utilizes validation setup within the model to enforce appropriate data constraints. Validation may be performed for save, create and updates.
#labels chapter,0.9.1

==Basic Setup==

In order to establish the full cycle of validation, 3 elements need to be in place:

 # A *model* file named as the database's (singular) table name. Example: `models/User.cfc`
 # A *controller* file for creating, saving or updating a model instance. Example: `controllers/Example.cfc`
 # A *view* file for displaying the original data inputs and an error list. Example: `views/example/index.cfm`

*Note:* Saving, creating, and updating model objects can also be done from the model file itself (or even in the view file if you want to veer completely off into the wild). But to keep things simple, all examples in this chapter will revolve around code in the controller files.

===The Model===

Validation in the model is always set in the `init()` method. Within this `init()` method, Wheels methods are called to establish individually-tailored validation per property.

{{{
<cfcomponent extends="Model">
  
    <cffunction name="init">
        <cfset validatesPresenceOf(property="nameFirst,nameLast", message="First and last name fields required")>
        <cfset validatesPresenceOf(property="email", message="Email field required")>
        <cfset validatesUniquenessOf(property="email", message="Email already in use")>
    </cffunction>

</cfcomponent>
}}}

The [validatesPresenceOf validatesPresenceOf()] method ensures that the associated form field does not have a string length of `0`. This is far simpler than implementing your own if-tests within the controller, testing with multiple conditions of the field such as `Len()`, `IsDefined()`, etc.

Additionally, the [validatesPresenceOf validatesPresenceOf()] `property` attribute accepts a list, thus allowing multiple fields to be validated and returned with the same message.

The [validatesUniquenessOf validatesUniquenessOf()] method runs a database `SELECT` with a `WHERE` on the form field's name/value. If a match is found, [validatesUniquenessOf validatesUniquenessOf()] returns an error and cancels the controller's action of save/create/update.

===The Controller===

The controller continues with the simplicity of validation setup, and at the most basic level requires only 5 lines of code to persist the form data or return to the original form page to display the list of errors.

{{{
<cfcomponent extends="Controller">

    <cffunction name="apply">

        <!--- User model from form fields via params --->
        <cfset newUser = model("user").new(params.newUser)>

        <!--- Persist new user --->
        <cfif newUser.save()>
            <cfset redirectTo(action="success")>
        <cfelse>
            <cfset renderPage(action="index")>
        </cfif>

    </cffunction>

</cfcomponent>
}}}

The first line of the action creates a `newUser` based on the `user` model and the form inputs (via the `params` struct).

Now, to persist the object to the database, the model's [save save()] call can be placed within a `<cfif>` test. If the save succeeds, the [save save()] method will return `true` and the contents of the `<cfif>` will be executed. But if any of the validations set up in the model fail, the [save save()] method returns `false` and the `<cfelse>` will execute.

The important step here is to recognize that the `<cfelse>` renders the original form input page. The reason for this is that the now-validated `newUser` model is in the scope of the `apply` action. If a [redirectTo redirectTo()] were used, the original `index` action would be called and the validation information would be lost.

===The View===

The view needs only be a simple form and associated inputs to the model's properties. The only aspect that sets this view apart from a non-validated form is the first line of Wheels code:

{{{
<cfoutput>

#errorMessagesFor("newUser")#

#startFormTag(action="apply")#
    #textField(objectName="newUser", property="nameFirst", label="First Name")#
    #textField(objectName="newUser", property="nameLast", label="Last Name")#
    #textField(objectName="newUser", property="email", label="Email")#
#endFormTag()#

</cfoutput>
}}}

The [errorMessagesFor errorMessagesFor()] call hands in the name of the model instance name expected when validation catches on the processed model and returns an error message. The [errorMessagesFor errorMessagesFor()] will output a unordered list with each error message as a list item.

==List of Available Validations==

 * [validatesConfirmationOf validatesConfirmationOf()]
 * [validatesExclusionOf validatesExclusionOf()]
 * [validatesFormatOf validatesFormatOf()]
 * [validatesInclusionOf validatesInclusionOf()]
 * [validatesLengthOf validatesLengthOf()]
 * [validatesNumericalityOf validatesNumericalityOf()]
 * [validatesPresenceOf validatesPresenceOf()]
 * [validatesUniquenessOf validatesUniquenessOf()]
 * [validate validate()]
 * [validateOnCreate validateOnCreate()]
 * [validateOnUpdate validateOnUpdate()]