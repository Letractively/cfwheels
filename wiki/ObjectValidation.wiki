#summary Wheels utilizes validation setup within the model to enforce appropriate data persistence. Validation may be performed for save, create and updates.
#labels chapter,1.0

== Basic Setup ==

In order to establish the full cycle of validation, three elements
need to be in place:

 # a *model* file named as the database's (singular) table name. Example: `models/User.cfc`
 # a *controller* file for creating, saving or updating a model instance. Example:Â´controllers/ExampleController.cfc`
 # a *view* page for displaying the original data inputs and an error list for
validation messages. Example: `views/examplecontroller/index.cfm`

Note: saving, creating and updating model objects can of course also be done from the model file itself (or even from the view if you want to) but to keep things simple all examples in this chapter will revolve around code in the controller files.

== The Model ==

Validation in the model is always set in the `init()` method. Within this `init()` method, Wheels methods are called to establish individually taylored validation per field.

{{{
<cfcomponent extends="Model">
  
  <cffunction name="init">
    <cfset validatesPresenceOf(property="nameFirst,nameLast", message="First and/or last name fields required")>
    <cfset validatesPresenceOf(property="email", message="Email
field required")>
    <cfset validatesUniquenessOf(property="email", message="Email
already in use")>
  </cffunction>

</cfcomponent>
}}}

The [validatesPresenceOf validatesPresenceOf()] method ensures that the associated form field does not have a string length of `0`. This is far simpler than implementing your own if-tests within the controller, testing with multiple conditions of the field such as `Len()`, `IsDefined()`, etc.

Additionally, the [validatesPresenceOf validatesPresenceOf()] `property` attribute accepts a list, thus allowing multiple fields to be validated and returned with the same message.

The [validatesUniquenessOf validatesUniquenessOf()] method runs a database `SELECT` with a `WHERE` on the form field's name/value. If a match is found [validatesUniquenessOf validatesUniquenessOf()] returns an error and cancels the controller's action of save/create/update.

==The Controller==

The controller continues with the simplicity of validation setup, and at the most basic level requires only 5 lines of code to persist the form data or return to the original form page to display the list of errors.

{{{
<cfcomponent extends="Controller">

  <cffunction name="apply">
    <!--- user model from form fields via params --->
    <cfset newUser = model("user").new(params.newUser)>

    <!--- persist new user --->
    <cfif newUser.save()>
      <cfset renderPage(action="success")>
    <cfelse>
      <cfset renderPage(action="index")>
    </cfif>
  </cffunction>

</cfcomponent>
}}}

The first line of the action creates a new `user` based on the `user` model and the form inputs (via the `params` `struct`).

Now, to persist the object to the database, the model [save save()] call is placed within an `<cfif>` test. If the save succeeds, the save function will return true and the contents of the `<cfif>` will be executed. But, if any of the validations setup in the model fails, the `save()` returns `false` and the `<cfelse>` will execute.

The important step here is to recognize that the `<cfelse>` renders the original form input page. The reason for this is that the now validated newUser model is in the scope of the `apply` action. If a `redirectTo()` were used, the original `index` action would be called and the validation information lost.

==The View==

The view need only be a simple form and associated inputs to the model's fields. The only aspect that sets this view apart from a non-validated form is the first line of Wheels code.

{{{
<cfoutput>
#errorMessagesFor("newUser")#

#startFormTag(controller="examplecontroller", action="submit")#
   #textField(objectName="newUser", property="nameFirst",
label="First Name", wrapLabel=false, append="<br />")#
   #textField(objectName="newUser", property="nameLast", label="Last
Name", wrapLabel=false, append="<br />")#
   #textField(objectName="newUser", property="email", label="Email",
wraplabel=false, append="<br />")#
 #endFormTag()#
</cfoutput>
}}}

The `errorMessagesFor()` method call hands in the name of the model instance name expected when validation catches on the processed model and returns an error message. The `errorMessagesFor()` will output a unordered list with each error message as a list item.